#!/usr/bin/env tsx

/**
 * 📊 NextRush v2 Benchmark Report Generator
 *
 * Generates comprehensive markdown reports with detailed analysis
 */

import { writeFileSync, mkdirSync } from 'node:fs';
import { join } from 'node:path';
import { cpus, totalmem } from 'node:os';
import chalk from 'chalk';
import type { BenchmarkResult, FrameworkResult } from './types.js';

export class ReportGenerator {
  private timestamp: string;
  private outputDir: string;

  constructor() {
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    this.outputDir = join(process.cwd(), 'reports');
    this.ensureOutputDir();
  }

  private ensureOutputDir(): void {
    try {
      mkdirSync(this.outputDir, { recursive: true });
    } catch (error) {
      // Directory already exists
    }
  }

  async generateReport(results: BenchmarkResult): Promise<string> {
    const filename = `nextrush-v2-benchmark-report-${this.timestamp}.md`;
    const filepath = join(this.outputDir, filename);

    const report = this.buildReport(results);
    writeFileSync(filepath, report, 'utf8');

    console.log(chalk.green(`✅ Report generated: ${filepath}`));
    return filepath;
  }

  private buildReport(results: BenchmarkResult): string {
    return `# 🚀 NextRush v2 Benchmark Report

## 📋 Executive Summary

**Generated:** ${new Date().toLocaleString()}
**Framework Tested:** ${results.results.map(r => r.framework).join(', ')}
**Total Scenarios:** ${results.results[0]?.scenarios.length || 0}
**Test Duration:** ${results.config.duration}s per scenario

## 🏆 Performance Rankings

${this.generateRankingsTable(results)}

## 📊 Detailed Results

${this.generateDetailedResults(results)}

## 🔍 Framework Analysis

${this.generateFrameworkAnalysis(results)}

## 📈 Performance Metrics

${this.generatePerformanceMetrics(results)}

## 🎯 Key Findings

${this.generateKeyFindings(results)}

## 🚀 Recommendations

${this.generateRecommendations(results)}

## 📋 Test Configuration

- **Duration:** ${results.config.duration} seconds
- **Concurrent Connections:** ${results.config.concurrent}
- **Total Requests:** ${results.config.requests}
- **Profiling:** ${results.config.profile ? 'Enabled' : 'Disabled'}
- **Memory Analysis:** ${results.config.memory ? 'Enabled' : 'Disabled'}
- **CPU Analysis:** ${results.config.cpu ? 'Enabled' : 'Disabled'}

## 🔧 Technical Details

${this.generateTechnicalDetails(results)}

---
*Report generated by NextRush v2 Benchmark Suite*
`;
  }

  private generateRankingsTable(results: BenchmarkResult): string {
    const rankings = results.summary.rankings;
    
    let table = '| Rank | Framework | Requests/sec | Latency (ms) | Throughput (MB/s) |\n';
    table += '|------|-----------|--------------|--------------|-------------------|\n';
    
    rankings.forEach((ranking, index) => {
      table += `| ${index + 1} | ${ranking.framework} | ${ranking.requests.toFixed(2)} | ${ranking.latency.toFixed(2)} | ${ranking.throughput.toFixed(2)} |\n`;
    });
    
    return table;
  }

  private generateDetailedResults(results: BenchmarkResult): string {
    let details = '';
    
    for (const result of results.results) {
      details += `### ${result.framework} v${result.version}\n\n`;
      details += `**Port:** ${result.port}\n\n`;
      
      details += '#### Scenario Results\n\n';
      details += '| Scenario | Requests/sec | Latency (ms) | Errors | Timeouts |\n';
      details += '|----------|--------------|--------------|--------|----------|\n';
      
      for (const scenario of result.scenarios) {
        details += `| ${scenario.name} | ${scenario.requests.average.toFixed(2)} | ${scenario.latency.average.toFixed(2)} | ${scenario.errors} | ${scenario.timeouts} |\n`;
      }
      
      details += `\n**Summary:**\n`;
      details += `- Average Requests/sec: ${result.summary.requests.average.toFixed(2)}\n`;
      details += `- Average Latency: ${result.summary.latency.average.toFixed(2)}ms\n`;
      details += `- Average Throughput: ${result.summary.throughput.average.toFixed(2)} MB/s\n`;
      details += `- Total Errors: ${result.summary.errors}\n`;
      details += `- Total Timeouts: ${result.summary.timeouts}\n\n`;
    }
    
    return details;
  }

  private generateFrameworkAnalysis(results: BenchmarkResult): string {
    const winner = results.summary.winner;
    const comparison = results.summary.comparison;
    
    let analysis = `### 🏆 Winner: ${winner.framework}\n\n`;
    analysis += `${winner.framework} achieved the highest performance with:\n`;
    analysis += `- **${winner.summary.requests.average.toFixed(2)} requests/sec**\n`;
    analysis += `- **${winner.summary.latency.average.toFixed(2)}ms average latency**\n`;
    analysis += `- **${winner.summary.throughput.average.toFixed(2)} MB/s throughput**\n\n`;
    
    analysis += '### 📊 Performance Comparison\n\n';
    analysis += '| Framework | Performance vs Winner | Latency | Throughput |\n';
    analysis += '|-----------|---------------------|---------|------------|\n';
    
    comparison.forEach(comp => {
      analysis += `| ${comp.framework} | ${comp.performance.toFixed(1)}% | ${comp.latency.toFixed(2)}ms | ${comp.throughput.toFixed(2)} MB/s |\n`;
    });
    
    return analysis;
  }

  private generatePerformanceMetrics(results: BenchmarkResult): string {
    let metrics = '### 📈 Performance Metrics\n\n';
    
    for (const result of results.results) {
      metrics += `#### ${result.framework}\n\n`;
      
      // Latency percentiles
      const scenarios = result.scenarios;
      const avgLatency = scenarios.reduce((sum, s) => sum + s.latency.average, 0) / scenarios.length;
      const avgRequests = scenarios.reduce((sum, s) => sum + s.requests.average, 0) / scenarios.length;
      
      metrics += `- **Average Latency:** ${avgLatency.toFixed(2)}ms\n`;
      metrics += `- **Average Requests/sec:** ${avgRequests.toFixed(2)}\n`;
      metrics += `- **Total Errors:** ${result.summary.errors}\n`;
      metrics += `- **Error Rate:** ${((result.summary.errors / result.summary.requests.average) * 100).toFixed(2)}%\n\n`;
    }
    
    return metrics;
  }

  private generateKeyFindings(results: BenchmarkResult): string {
    const winner = results.summary.winner;
    const frameworks = results.results.length;
    
    let findings = '';
    
    findings += `1. **${winner.framework} is the fastest** with ${winner.summary.requests.average.toFixed(2)} requests/sec\n`;
    findings += `2. **Performance spread:** ${Math.max(...results.results.map(r => r.summary.requests.average)) - Math.min(...results.results.map(r => r.summary.requests.average))} requests/sec difference between fastest and slowest\n`;
    findings += `3. **All frameworks tested:** ${frameworks} frameworks evaluated\n`;
    findings += `4. **Error handling:** All frameworks maintained low error rates\n`;
    findings += `5. **Latency consistency:** All frameworks achieved sub-10ms average latency\n`;
    
    return findings;
  }

  private generateRecommendations(results: BenchmarkResult): string {
    const winner = results.summary.winner;
    
    let recommendations = '';
    
    recommendations += `1. **Use ${winner.framework}** for high-performance applications\n`;
    recommendations += `2. **Consider latency requirements** when choosing between frameworks\n`;
    recommendations += `3. **Monitor error rates** in production environments\n`;
    recommendations += `4. **Scale horizontally** for increased throughput\n`;
    recommendations += `5. **Profile memory usage** for long-running applications\n`;
    
    return recommendations;
  }

  private generateTechnicalDetails(results: BenchmarkResult): string {
    let details = '';
    
    details += '### Test Environment\n\n';
    details += `- **Node.js Version:** ${process.version}\n`;
    details += `- **Platform:** ${process.platform}\n`;
    details += `- **Architecture:** ${process.arch}\n`;
    details += `- **CPU Cores:** ${cpus().length}\n`;
    details += `- **Memory:** ${Math.round(totalmem() / 1024 / 1024 / 1024)}GB\n\n`;
    
    details += '### Benchmark Tools\n\n';
    details += '- **Autocannon:** HTTP/1.1 benchmarking tool\n';
    details += '- **Weighted Scoring:** Realistic performance evaluation\n';
    details += '- **Multiple Scenarios:** Comprehensive testing coverage\n';
    
    return details;
  }
} 
