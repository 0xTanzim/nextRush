/**
 * üè¢ NextRush Application - Enterprise Plugin-Based Architecture [ARCHIVED]
 * ‚ö†Ô∏è  DEPRECATED: This file is kept for reference but not actively used
 * ‚úÖ Main implementation is in ./app/application.ts
 */

import { Application } from './app/application';
import { NextRushRequest, NextRushResponse } from '../types/express';
import { PluginManager } from '../plugins/core/plugin-manager';
import { RouterPlugin } from '../plugins/implementations/router.plugin';
import { WebSocketPlugin } from '../plugins/implementations/websocket.plugin';
import { StaticFilesPlugin } from '../plugins/implementations/static-files.plugin';
import { TemplatePlugin } from '../plugins/implementations/template.plugin';
import { EventEmitter } from 'events';
import { createServer, Server, IncomingMessage, ServerResponse } from 'http';

/**
 * Application configuration
 */
export interface ApplicationConfig {
  plugins?: {
    enableLogging?: boolean;
    logLevel?: 'debug' | 'info' | 'warn' | 'error';
    autoStart?: boolean;
  };
  server?: {
    port?: number;
    host?: string;
    backlog?: number;
  };
}

/**
 * Enterprise NextRush Application
 * Plugin-based, composable, type-safe web framework
 */
export class NextRushApplication extends EventEmitter implements Application {
  private readonly pluginManager: PluginManager;
  private readonly config: Record<string, unknown> = {};
  private server?: Server;
  private isListening = false;

  // Core plugins
  private routerPlugin?: RouterPlugin;
  private webSocketPlugin?: WebSocketPlugin;
  private staticFilesPlugin?: StaticFilesPlugin;
  private templatePlugin?: TemplatePlugin;

  constructor(config: ApplicationConfig = {}) {
    super();
    
    // Initialize plugin manager
    this.pluginManager = new PluginManager(this, config.plugins);
    
    // Store application config
    this.config = { ...config };
    
    // Set up plugin manager events
    this.setupPluginEvents();
    
    // Install core plugins
    this.installCorePlugins().catch(error => {
      console.error('Failed to install core plugins:', error);
    });
  }

  // HTTP Methods (delegated to RouterPlugin)
  public get(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public post(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public put(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public delete(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public patch(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public head(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public options(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  public all(path: string, ...handlers: any[]): this {
    this.ensureRouter();
    return this;
  }

  // Middleware (delegated to RouterPlugin)
  public use(pathOrHandler: any, handler?: any): this {
    this.ensureRouter();
    return this;
  }

  // WebSocket (delegated to WebSocketPlugin)
  public ws(path: string, handler: any): this {
    this.ensureWebSocket();
    return this;
  }

  // Static Files (delegated to StaticFilesPlugin)
  public static(mountPath: string, rootPath: string, options?: any): this {
    this.ensureStaticFiles();
    return this;
  }

  // Template Engine (delegated to TemplatePlugin)
  public setViews(path: string, options?: any): this {
    this.ensureTemplate();
    return this;
  }

  public async render(template: string, data?: Record<string, unknown>): Promise<string> {
    this.ensureTemplate();
    return this.templatePlugin!.render(template, data);
  }

  // Server Control
  public async listen(
    portOrConfig?: number | ServerConfig,
    hostOrCallback?: string | (() => void),
    callback?: () => void
  ): Promise<void> {
    if (this.isListening) {
      throw new Error('Server is already listening');
    }

    // Parse arguments
    let port = 3000;
    let host = 'localhost';
    let cb: (() => void) | undefined;

    if (typeof portOrConfig === 'number') {
      port = portOrConfig;
      if (typeof hostOrCallback === 'string') {
        host = hostOrCallback;
        cb = callback;
      } else if (typeof hostOrCallback === 'function') {
        cb = hostOrCallback;
      }
    } else if (typeof portOrConfig === 'object') {
      port = portOrConfig.port || 3000;
      host = portOrConfig.host || 'localhost';
      cb = hostOrCallback as (() => void);
    } else if (typeof portOrConfig === 'function') {
      cb = portOrConfig;
    }

    try {
      // Start all plugins
      await this.pluginManager.startAll();

      // Create HTTP server
      this.server = createServer((req, res) => {
        this.handleRequest(req, res).catch(error => {
          console.error('Request handling error:', error);
          if (!res.headersSent) {
            res.writeHead(500, { 'Content-Type': 'application/json' });
            res.end(JSON.stringify({ error: 'Internal Server Error' }));
          }
        });
      });

      // Set up WebSocket upgrade handling
      this.server.on('upgrade', (request, socket, head) => {
        if (this.webSocketPlugin) {
          const handled = this.webSocketPlugin.handleUpgrade(request, socket, head);
          if (!handled) {
            socket.destroy();
          }
        } else {
          socket.destroy();
        }
      });

      // Start listening
      await new Promise<void>((resolve, reject) => {
        this.server!.listen(port, host, () => {
          this.isListening = true;
          this.emit('listening', { port, host });
          if (cb) cb();
          resolve();
        });

        this.server!.on('error', reject);
      });

      console.log(`üöÄ NextRush server listening on http://${host}:${port}`);
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  public async close(): Promise<void> {
    if (!this.isListening || !this.server) {
      return;
    }

    try {
      // Stop all plugins
      await this.pluginManager.stopAll();

      // Close HTTP server
      await new Promise<void>((resolve, reject) => {
        this.server!.close((error) => {
          if (error) {
            reject(error);
          } else {
            this.isListening = false;
            this.emit('closed');
            resolve();
          }
        });
      });

      console.log('üõë NextRush server closed');
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  // Configuration
  public set(key: string, value: unknown): this {
    this.config[key] = value;
    this.emit('config:set', { key, value });
    return this;
  }

  public getConfig(key: string): unknown {
    return this.config[key];
  }

  // Plugin Management
  public async install(plugin: any): Promise<this> {
    await this.pluginManager.register(plugin);
    return this;
  }

  public async uninstall(pluginName: string): Promise<this> {
    const plugin = this.pluginManager.get(pluginName);
    if (plugin) {
      await this.pluginManager.uninstall(pluginName);
    }
    return this;
  }

  /**
   * Get plugin manager for advanced plugin operations
   */
  public getPluginManager(): PluginManager {
    return this.pluginManager;
  }

  /**
   * Get application health status
   */
  public getHealth(): Record<string, any> {
    return {
      status: this.isListening ? 'healthy' : 'stopped',
      plugins: this.pluginManager.getHealth(),
      server: {
        listening: this.isListening,
        address: this.server?.address()
      }
    };
  }

  // Private methods
  private async installCorePlugins(): Promise<void> {
    // Install core plugins in order of dependency
    this.routerPlugin = new RouterPlugin();
    this.webSocketPlugin = new WebSocketPlugin();
    this.staticFilesPlugin = new StaticFilesPlugin();
    this.templatePlugin = new TemplatePlugin();

    await this.pluginManager.register(this.routerPlugin);
    await this.pluginManager.register(this.webSocketPlugin);
    await this.pluginManager.register(this.staticFilesPlugin);
    await this.pluginManager.register(this.templatePlugin);
  }

  private setupPluginEvents(): void {
    this.pluginManager.on('plugin:error', ({ pluginName, error }) => {
      this.emit('plugin:error', { pluginName, error });
    });

    this.pluginManager.on('manager:started', () => {
      this.emit('plugins:started');
    });

    this.pluginManager.on('manager:stopped', () => {
      this.emit('plugins:stopped');
    });
  }

  private async handleRequest(req: IncomingMessage, res: ServerResponse): Promise<void> {
    // Enhance request and response objects
    const enhancedReq = this.enhanceRequest(req);
    const enhancedRes = this.enhanceResponse(res);

    try {
      // Try static files first
      if (this.staticFilesPlugin) {
        const staticHandled = await this.staticFilesPlugin.handleRequest(enhancedReq, enhancedRes);
        if (staticHandled) {
          return;
        }
      }

      // Try router
      if (this.routerPlugin) {
        const routeHandled = await this.routerPlugin.handleRequest(enhancedReq, enhancedRes);
        if (routeHandled) {
          return;
        }
      }

      // No handler found - 404
      if (!res.headersSent) {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Not Found' }));
      }
    } catch (error) {
      console.error('Request handling error:', error);
      if (!res.headersSent) {
        res.writeHead(500, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Internal Server Error' }));
      }
    }
  }

  private enhanceRequest(req: IncomingMessage): NextRushRequest {
    const enhanced = req as NextRushRequest;
    
    // Parse URL and query parameters
    const url = new URL(req.url || '/', `http://${req.headers.host}`);
    (enhanced as any).query = Object.fromEntries(url.searchParams);
    (enhanced as any).params = {};
    (enhanced as any).cookies = this.parseCookies(req.headers.cookie || '');
    
    return enhanced;
  }

  private enhanceResponse(res: ServerResponse): NextRushResponse {
    const enhanced = res as NextRushResponse;

    // Add helper methods
    enhanced.status = function(code: number) {
      this.statusCode = code;
      return this;
    };

    enhanced.json = function(data: unknown) {
      this.setHeader('Content-Type', 'application/json');
      this.end(JSON.stringify(data));
      return this;
    };

    enhanced.send = function(data: string | Buffer) {
      if (typeof data === 'string') {
        this.setHeader('Content-Type', 'text/html');
      }
      this.end(data);
      return this;
    };

    enhanced.render = async (template: string, data?: Record<string, unknown>) => {
      if (this.templatePlugin) {
        const html = await this.templatePlugin.render(template, data);
        enhanced.setHeader('Content-Type', 'text/html');
        enhanced.end(html);
      } else {
        enhanced.status(500).json({ error: 'Template engine not available' });
      }
      return enhanced;
    };

    enhanced.redirect = function(url: string) {
      this.writeHead(302, { 'Location': url });
      this.end();
      return this;
    };

    enhanced.cookie = function(name: string, value: string, options: any = {}) {
      const cookie = `${name}=${value}; Path=${options.path || '/'}`;
      this.setHeader('Set-Cookie', cookie);
      return this;
    };

    enhanced.clearCookie = function(name: string) {
      this.cookie(name, '', { expires: new Date(0) });
      return this;
    };

    return enhanced;
  }

  private parseCookies(cookieHeader: string): Record<string, string> {
    const cookies: Record<string, string> = {};
    
    cookieHeader.split(';').forEach(cookie => {
      const [name, value] = cookie.split('=').map(c => c.trim());
      if (name && value) {
        cookies[name] = value;
      }
    });

    return cookies;
  }

  private ensureRouter(): void {
    if (!this.routerPlugin) {
      throw new Error('Router plugin not available');
    }
  }

  private ensureWebSocket(): void {
    if (!this.webSocketPlugin) {
      throw new Error('WebSocket plugin not available');
    }
  }

  private ensureStaticFiles(): void {
    if (!this.staticFilesPlugin) {
      throw new Error('Static files plugin not available');
    }
  }

  private ensureTemplate(): void {
    if (!this.templatePlugin) {
      throw new Error('Template plugin not available');
    }
  }
}

/**
 * Create a new NextRush application
 */
export function createApp(config?: ApplicationConfig): NextRushApplication {
  return new NextRushApplication(config);
}
